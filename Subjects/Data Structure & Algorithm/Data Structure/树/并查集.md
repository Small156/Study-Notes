# 并查集

并查集（Union Find）又称「不相交集合（Disjoint Set）」，专门用于 **动态处理** 不相交集合的「合并」与「查询」问题。并查集主要支持如下操作：

* 合并（Union）：把两个不相交的集合合并为一个集合。
* 查询（Find）：查询两个元素是否在同一个集合中。

并查集最常见的一种实现为：**不相交集合森林（Disjoint-set forest）。**

并查集主要用于解决：**网络中的连通性** 问题。

目录：

- [并查集](#并查集)
  - [并查集设计思想](#并查集设计思想)
    - [quick-find：基于 id](#quick-find基于-id)
    - [quick-union：基于 parent](#quick-union基于-parent)
  - [并查集 - 代表元法实现](#并查集---代表元法实现)
    - [按秩合并](#按秩合并)
    - [路径压缩](#路径压缩)
    - [时间复杂度分析](#时间复杂度分析)
    - [代码模板](#代码模板)
  - [常见题型](#常见题型)
  - [参考链接](#参考链接)

## 并查集设计思想

### quick-find：基于 id

「基于 id」的思想：给每一个元素（顶点）分配一个唯一标识，称为 `id`。

* 初始化：所有元素的 `id` 都不一样，表示一个元素单独属于一个集合。
* 如果两个元素的 `id` 一样，标识它们同属于一个集合；
* 合并：需要将其中一个集合中的所有元素的 `id` 赋值成为另一个集合的 `id`（一个集合中的所有元素的 `id` 均一样）。

「基于 id」思想的优缺点分析：

* 优点：查询两个元素是否在一个集合中很快，时间复杂度为 $O(1)$；
* 缺点：把两个集合合并成一个集合较慢，需要遍历其中一个集合中的所有元素。

### quick-union：基于 parent

「基于 parent」的思想：记录每个顶点的父亲顶点是谁。这样设计「并查集」的思想也叫「代表元」法。

「代表元」法不再使用 `id` 数组，而使用 `parent` 数组。`parent` 数组的定义是：`parent[i]` 表示标识为 `i` 的结点的父亲结点。规定根结点的父亲结点是自己。

因此，该方式实现的「并查集」组织成了 **若干个不相交的树形结构**，并且我们在访问结点的时候，总是按照「从下到上」进行访问的。

「基于 parent」思想的优缺点分析：

* 优点：把两个集合合并成一个集合较快，只需修改代表元素的父节点；
* 缺点：查询两个元素是否在一个集合中需要递归向上查询，如果树的高度过高，则性能较低。

## 并查集 - 代表元法实现

代表元法实现并查集，可能会出现树的高度过高，查询性能降低的情况。解决方案有 **按秩合并** 与 **路径压缩**。

### 按秩合并

按「秩」合并的意思是：让树的「秩」较小的树的根结点，指向树的「秩」较大的树的根结点。

这里的「秩」有两种含义，分别用于不同的场景：

* 按 `size` 合并，用于需要维护每个连通分量结点个数的时候；
  * 按 size 合并的意思是让树的「结点总数」较小的树的根结点，指向树的「结点总数」较大的树的根结点。
* 按 `rank` 合并，绝大多数时候。
  * 按 rank 合并的意思是让树的「高度」较小的树的根结点，指向树的「高度」较大的树的根结点。
  * 之所以把「高度」称为 rank ，是因为同时使用「按秩合并」和「路径压缩」的时候，树的「高度」很难维护其准确的定义，但是依然可以作为合并时候的依据，因此成为「秩」。

### 路径压缩

路径压缩当中的完全压缩是指把从「查询结点」到「根结点」沿途经过的所有结点都指向根结点。

### 时间复杂度分析

当并查集中的元素个数为 $n$ 时，单次并查集操作的时间复杂度如下：

优化                | 平均时间复杂度 | 最坏时间复杂度
------------------|:--------------:|:----------:
无优化              |   $O(logn)$    |     $O(n)$
按秩合并            |   $O(logn)$    |   $O(logn)$
路径压缩            |   $O(α(n))$    |   $O(logn)$
按秩合并 + 路径压缩 |   $O(α(n))$    |   $O(α(n))$

这里 $α$ 表示阿克曼函数的反函数，在宇宙可观测的 $n$ 内（例如宇宙中包含的粒子总数），$α(n)$ 不会超过 5。

### 代码模板

**eg 1.** 按 `size` 合并 和 路径压缩，适用于需要维护 **每个集合的节点数量** 以及 **总连通分量数目** 的情况。

```C++
class UnionFind {
public:
    int n;              // 集合节点总数
    int setCnt;         // 当前连通分量数目
    vector<int> parent; // 记录各节点父节点
    vector<int> size;   // 各集合节点数目

public:
    // 初始化
    UnionFind(int _n): n(_n), setCnt(_n), parent(_n), size(_n, 1) {
        // 用顺序递增的值初始化 parent，即初始化各节点 parent 为自身
        iota(parent.begin(), parent.end(), 0);
    }

    // 查找节点父节点
    int find(int x) {
        return parent[x] == x ? x : (parent[x] = find(parent[x]));
    }
    
    // 判断两个节点是否相连
    bool isConnect(int x, int y) {
        return find(x) == find(y);
    }

    // 合并两个节点
    bool unite(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) return false;
        
        if (size[x] < size[y]) swap(x, y);
        parent[y] = x;
        size[x] += size[y];
        
        --setCnt;
        return true;
    }
};
```

**eg 2.** 按 `rank` 合并

```C++
class UnionFind {
private:
    int n;              // 集合节点总数
    int setCnt;         // 当前连通分量数目
    vector<int> parent; // 记录各节点父节点
    vector<int> rank;   // 各集合秩

public:
    // rank(_n, 1) - 初始化各集合秩为 1
    UnionFind(int _n): n(_n), setCnt(_n), parent(_n), rank(_n, 1) {
        iota(parent.begin(), parent.end(), 0);
    }

    //......

    // 合并两个节点
    bool unite(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) return false;
        
        if (rank[x] <= rank[y]) parent[x] = y;
        else parent[y] = x;

        // 两棵树高度相同，合并后新高度 + 1
        if (rank[x] == rank[y]) rank[y]++;

        --setCnt;
        return true;
    }
    
    //......
};
```

## 常见题型

TODO

## 参考链接

* [并查集 - 力扣](https://leetcode-cn.com/leetbook/read/disjoint-set/oviefi/)
* [算法学习笔记(1) : 并查集](https://zhuanlan.zhihu.com/p/93647900)
* [并查集 - wiki](https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86)
* [C++】超实用并查集模板，闪现跟了，有什么好说的？](https://leetcode-cn.com/problems/find-all-people-with-secret/solution/5941c-bing-cha-ji-yi-miao-liao-you-shi-y-x8s9/)
* [并查集各种情况下的时间复杂度 - zerotrac](https://leetcode-cn.com/problems/number-of-provinces/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-bing-cha-0unne/)
