# 并查集

并查集（Union Find）又称「不相交集合（Disjoint Set）」，专门用于 **动态处理** 不相交集合的「合并」与「查询」问题。并查集主要支持如下操作：

* 合并（Union）：把两个不相交的集合合并为一个集合。
* 查询（Find）：查询两个元素是否在同一个集合中。

并查集最常见的一种实现为：**不相交集合森林（Disjoint-set forest）。**

并查集主要用于解决：**网络中的连通性** 问题。

目录：

- [并查集](#并查集)
  - [并查集设计思想](#并查集设计思想)
    - [quick-find：基于 id](#quick-find基于-id)
    - [quick-union：基于 parent](#quick-union基于-parent)
  - [并查集 - 代表元法实现](#并查集---代表元法实现)
    - [按秩合并](#按秩合并)
    - [路径压缩](#路径压缩)
    - [时间复杂度分析](#时间复杂度分析)
    - [代码模板](#代码模板)
  - [常见题型](#常见题型)
  - [参考链接](#参考链接)

## 并查集设计思想

### quick-find：基于 id

「基于 id」的思想：给每一个元素（顶点）分配一个唯一标识，称为 `id`。

* 初始化：所有元素的 `id` 都不一样，表示一个元素单独属于一个集合。
* 如果两个元素的 `id` 一样，标识它们同属于一个集合；
* 合并：需要将其中一个集合中的所有元素的 `id` 赋值成为另一个集合的 `id`（一个集合中的所有元素的 `id` 均一样）。

「基于 id」思想的优缺点分析：

* 优点：查询两个元素是否在一个集合中很快，时间复杂度为 $O(1)$；
* 缺点：把两个集合合并成一个集合较慢，需要遍历其中一个集合中的所有元素。

### quick-union：基于 parent

「基于 parent」的思想：记录每个顶点的父亲顶点是谁。这样设计「并查集」的思想也叫「代表元」法。

「代表元」法不再使用 `id` 数组，而使用 `parent` 数组。`parent` 数组的定义是：`parent[i]` 表示标识为 `i` 的节点的父亲节点。规定根节点的父亲节点是自己。

因此，该方式实现的「并查集」组织成了 **若干个不相交的树形结构**，并且我们在访问节点的时候，总是按照「从下到上」进行访问的。

「基于 parent」思想的优缺点分析：

* 优点：把两个集合合并成一个集合较快，只需修改代表元素的父节点；
* 缺点：查询两个元素是否在一个集合中需要递归向上查询，如果树的高度过高，则性能较低。

## 并查集 - 代表元法实现

代表元法实现并查集，可能会出现树的高度过高，查询性能降低的情况。解决方案有 **按秩合并** 与 **路径压缩**。

### 按秩合并

按「秩」合并的意思是：让树的「秩」较小的树的根节点，指向树的「秩」较大的树的根节点。

这里的「秩」有两种含义，分别用于不同的场景：

* 按 `size` 合并，用于需要维护每个连通分量节点个数的时候；
  * 按 size 合并的意思是让树的「节点总数」较小的树的根节点，指向树的「节点总数」较大的树的根节点。
* 按 `rank` 合并，绝大多数时候。
  * 按 rank 合并的意思是让树的「高度」较小的树的根节点，指向树的「高度」较大的树的根节点。
  * 之所以把「高度」称为 rank ，是因为同时使用「按秩合并」和「路径压缩」的时候，树的「高度」很难维护其准确的定义，但是依然可以作为合并时候的依据，因此成为「秩」。

### 路径压缩

路径压缩当中的完全压缩是指把从「查询节点」到「根节点」沿途经过的所有节点都指向根节点。

### 时间复杂度分析

当并查集中的元素个数为 $n$ 时，单次并查集操作的时间复杂度如下：

优化                | 平均时间复杂度 | 最坏时间复杂度
------------------|:--------------:|:----------:
无优化              |   $O(logn)$    |     $O(n)$
按秩合并            |   $O(logn)$    |   $O(logn)$
路径压缩            |   $O(α(n))$    |   $O(logn)$
按秩合并 + 路径压缩 |   $O(α(n))$    |   $O(α(n))$

这里 $α$ 表示阿克曼函数的反函数，在宇宙可观测的 $n$ 内（例如宇宙中包含的粒子总数），$α(n)$ 不会超过 5。

### 代码模板

**eg 1.** 按 `size` 合并 和 路径压缩，适用于需要维护 **每个集合的节点数量** 的情况。

```C++
class UnionFind {
public:
    int n;              // 集合节点总数
    int setCnt;         // 当前连通分量数目
    vector<int> parent; // 记录各节点父节点
    vector<int> size;   // 各集合节点数目

public:
    // 初始化
    UnionFind(int _n): n(_n), setCnt(_n), parent(_n), size(_n, 1) {
        // 用顺序递增的值初始化 parent，即初始化各节点 parent 为自身
        iota(parent.begin(), parent.end(), 0);
    }

    // 查找节点父节点
    int find(int x) {
        return parent[x] == x ? x : (parent[x] = find(parent[x]));
    }
    
    // 判断两个节点是否相连
    bool isConnect(int x, int y) {
        return find(x) == find(y);
    }

    // 合并两个节点
    bool unite(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) return false;
        
        if (size[x] < size[y]) swap(x, y);
        parent[y] = x;
        size[x] += size[y];
        
        --setCnt;
        return true;
    }
};
```

**eg 2.** 按 `rank` 合并 和 路径压缩。

```C++
class UnionFind {
private:
    int n;              // 集合节点总数
    int setCnt;         // 当前连通分量数目
    vector<int> parent; // 记录各节点父节点
    vector<int> rank;   // 各集合秩

public:
    // rank(_n, 1) - 初始化各集合秩为 1
    UnionFind(int _n): n(_n), setCnt(_n), parent(_n), rank(_n, 1) {
        iota(parent.begin(), parent.end(), 0);
    }

    //......

    // 合并两个节点
    bool unite(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) return false;
        
        if (rank[x] <= rank[y]) parent[x] = y;
        else parent[y] = x;

        // 两棵树高度相同，合并后新高度 + 1
        if (rank[x] == rank[y]) rank[y]++;

        --setCnt;
        return true;
    }
    
    //......
};
```

**总结：** eg 1 - 2 中的关键数据结构 `parent` 为 `vector<int>`，其保存值为其父节点索引值，同时需要在调用构造函数时确定范围并进行初始化，故仅适用于：

* 集合节点取值可抽象为 `整型`，如：`int`；
* 集合节点的取值范围事先确定且连续。

常见应用场景为：给定大小为 `n` 的数组，将该数组的索引范围 `[0, n)` 视为集合节点。

典型例题：

* [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)
* [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)
* [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)

**eg 3.** 集合节点为 **字符串型** 或 **集合取值范围事先不确定。**

```C++
class UnionFind {
private:
    // 利用无序 map 来记录可扩展的映射关系（当集合元素为整型时，修改对应的 key 类型即可）
    unordered_map<string, string> parent;
    unordered_map<string, int> rank;     

public:
    /* 由于事先不确定集合取值范围，且 parent map 在 find 过程中动态初始化，故不需要构造函数 */

    string find(const string &x) {
        // 若不在 parent map 中，将其初始化指向自身
        if (!parent.count(x)) parent[x] = x;
        return x == parent[x] ? x : (parent[x] = find(parent[x]));
    }
    
    bool unite(const string &x, const string &y) {
        string nx = find(x), ny = find(y);
        //......
    }

    //......
};
```

**Tips：** **eg 3** 场景，还可以事先遍历整个集合，在遍历过程中利用 `map` 建立 `string` 到 `int` 间的映射，然后将该 `int` 值作为集合节点元素应用于并查集。即将其转化为了 **eg 1 - 2** 场景。

```C++
// 由于事先不确定集合元素数量，故需要根据题目数据量，创建一个足够大的数组
vector<int> parent(MAXN), rank(MAXN);

unordered_map<string,int> s2id; // string to index
int i = 0;

// 对整个集合建立连续的整型索引
for (auto &str : arr) {
    if (s2id.count(str)) continue;
    s2id[str] = i++;
}

// 合并字符串对应的整型索引
for (...) {
    uf.unite(s2id[str1], s2id[str2]);
}
```

典型例题：

* [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)
* [737. 句子相似性 II](https://leetcode-cn.com/problems/sentence-similarity-ii/)
* [1258. 近义词句子](https://leetcode-cn.com/problems/synonymous-sentences/)
* [面试题 17.07. 婴儿名字](https://leetcode-cn.com/problems/baby-names-lcci/)

## 常见题型

二维地图

合并后续操作
TODO

## 参考链接

* [并查集 - 力扣](https://leetcode-cn.com/leetbook/read/disjoint-set/oviefi/)
* [算法学习笔记(1) : 并查集](https://zhuanlan.zhihu.com/p/93647900)
* [并查集 - wiki](https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86)
* [C++】超实用并查集模板，闪现跟了，有什么好说的？](https://leetcode-cn.com/problems/find-all-people-with-secret/solution/5941c-bing-cha-ji-yi-miao-liao-you-shi-y-x8s9/)
* [并查集各种情况下的时间复杂度 - zerotrac](https://leetcode-cn.com/problems/number-of-provinces/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-bing-cha-0unne/)
