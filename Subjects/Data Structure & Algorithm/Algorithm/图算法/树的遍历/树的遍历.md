# 树的遍历

树的遍历（也称为树的搜索）是图的遍历的一种，指的是按照某种规则，不重复地访问某种树的所有节点的过程。具体的访问操作可能是检查节点的值、更新节点的值等。不同的遍历方式，其访问节点的顺序是不一样的。

目录：

- [树的遍历](#树的遍历)
  - [深度优先遍历](#深度优先遍历)
    - [二叉树的前序遍历](#二叉树的前序遍历)
    - [二叉树的中序遍历](#二叉树的中序遍历)
    - [二叉树的后序遍历](#二叉树的后序遍历)
    - [运用递归解决树的问题](#运用递归解决树的问题)
  - [广度优先遍历](#广度优先遍历)
    - [二叉树的层序遍历](#二叉树的层序遍历)
  - [N 叉树的遍历](#n-叉树的遍历)
    - [N 叉树的前序遍历](#n-叉树的前序遍历)
    - [N 叉树的后序遍历](#n-叉树的后序遍历)
    - [N 叉树的层序遍历](#n-叉树的层序遍历)
  - [参考链接](#参考链接)

## 深度优先遍历

**基本框架：**

```C++
void traverse(TreeNode *root) {
    // 前序遍历
    traverse(root->left);
    // 中序遍历
    traverse(root->right);
    // 后序遍历
}
```

### 二叉树的前序遍历

前序遍历：根结点 ---> 左子树 ---> 右子树

**eg 1.1.1 递归**

```C++
class Solution {
public:
    void preorder(TreeNode *root, vector<int> &res) {
        if (root == nullptr) return;

        res.push_back(root->val);
        preorder(root->left, res);
        preorder(root->right, res);
    }

    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> res;
        preorder(root, res);
        return res;
    }
};
```

**eg 1.1.2 迭代**

```C++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;

        /* 注意 1. 同时判断 root 和 stack 不为空
        因为可能出现节点 root 为空，但是 stack 不为空，需要再次弹出栈的操作 */
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {        // 注意 2. 直到节点为空，找到最左节点
                res.emplace_back(root->val); // 注意 3. 前序遍历，在此添加 res
                stk.emplace(root);
                root = node->left;
            }

            /* 注意 4. 前序遍历：根->左->右，此时 根、左已经访问完毕，
            因此弹出根节点，并访问其右节点 */
            root = stk.top();
            stk.pop();
            root = root->right;
        }

        return res;
    }
};
```

### 二叉树的中序遍历

中序遍历：左子树---> 根结点 ---> 右子树

**eg 1.2.1 递归**

```C++
class Solution {
public:
    vector<int> res;
    vector<int> inorderTraversal(TreeNode* root) {
        inorder(root, res);
        return res;
    }

    void inorder(TreeNode* root, vector<int>& res) {
        if (root == nullptr) return;

        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
    }
};
```

**eg 1.2.2 迭代**

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;

        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val); // 注意：中序遍历，在此添加 res
            root = root->right;
        }

        return res;
    }
};
```

### 二叉树的后序遍历

后序遍历：左子树 ---> 右子树 ---> 根结点

**eg 1.3.1 递归**

```C++
class Solution {
public:
    void postorder(TreeNode *root, vector<int> &res) {
        if (root == nullptr) return;
        
        postorder(root->left, res);
        postorder(root->right, res);
        res.push_back(root->val);
    }

    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        postorder(root, res);
        return res;
    }
};
```

**eg 1.3.2 迭代**

```C++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        stack<TreeNode *> stk;

        // 注意 1. 声明 prev 指针用于保存前一个访问的节点，以避免重复访问右节点
        TreeNode *prev = nullptr;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.emplace(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();

            // 注意 2. 当右节点为空 或 右节点已经访问过时，访问根节点
            if (root->right == nullptr || root->right == prev) {
                res.emplace_back(root->val);
                prev = root;
                root = nullptr;
            } else {

                // 注意 3. 右节点还未访问，需要重新将根节点压入栈，并跳转到右节点
                stk.emplace(root);
                root = root->right;
            }
        }

        return res;
    }
};
```

### 运用递归解决树的问题

**“自顶向下” 的解决方案**

“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点，即，上层将数据传递给下层，直到最后一层停止递归。 所以 “自顶向下” 的解决方案可以被认为是一种 **前序遍历**。 通常，递归函数 `top_down(root, params)` 如下所示：

```C++
1. return specific value for null node
2. update the answer if needed                      // answer <-- params
3. left_ans = top_down(root.left, left_params)      // left_params <-- root.val, params
4. right_ans = top_down(root.right, right_params)   // right_params <-- root.val, params
5. return the answer if needed                      // answer <-- left_ans, right_ans
```

**“自底向上” 的解决方案**

“自底向上” 是另一种递归方法。 在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案，即，上层数据依赖于下层。 这个过程可以看作是 **后序遍历** 的一种。 通常，递归函数 `bottom_up(root)` 如下所示：

```C++
1. return specific value for null node
2. left_ans = bottom_up(root.left)    // call function recursively for left child
3. right_ans = bottom_up(root.right)  // call function recursively for right child
4. return answers                     // answer <-- left_ans, right_ans, root.val
```

**总结**

当需要用到递归来解决树的问题时，可以先从以下几个角度进行思考：

**case 1.**

1. 能确定一些参数，并且能从该节点自身解决出发寻找答案；
2. 可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数。

若满足以上条件，则应考虑使用 “自顶向下” 的递归来解决问题。

**case 2.**

若满足，对于树中的任意一个节点，如果你知道它子节点的答案，就能够计算出该节点的答案，则应考虑 “自底向上” 递归。

## 广度优先遍历

### 二叉树的层序遍历

广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按层序遍历。

```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (root == nullptr) return res;   // 注意 1. 空指针直接返回，避免 nullptr 压入栈

        queue<TreeNode*> q;
        q.push(root);
        TreeNode *node;
        while (!q.empty()) {               // 注意 2. 直到队列为空
            int size = q.size();           // 注意 3. 提前获取队列大小
            res.push_back(vector<int> ());
            while (size--) {               // 注意 4. 循环特定次数
                node = q.front();
                q.pop();
                res.back().push_back(node->val);
                if (node->left != nullptr) q.push(node->left);
                if (node->right != nullptr) q.push(node->right);
            }
        }

        return res;
    }
};
```

## N 叉树的遍历

### N 叉树的前序遍历

**eg 3.1.1 递归**

```C++
class Solution {
public:
    vector<int> res;
    vector<int> preorder(Node* root) {
        preorderTraversal(root);
        return res;
    }

    void preorderTraversal(Node *node) {
        if (node == nullptr) return;
        
        res.emplace_back(node->val);
        for (auto &child : node->children) {
            preorderTraversal(child);
        }
    }
};
```

**eg 3.1.2 迭代**

```C++
class Solution {
public:
    vector<int> preorder(Node* root) {
        vector<int> res;
        if (root == nullptr) return res;

        stack<Node*> stk;
        stk.push(root);
        while (!stk.empty()) {
            root = stk.top();
            stk.pop();
            res.emplace_back(root->val);
            for (int i = root->children.size() - 1; i >= 0; --i) {
                stk.push(root->children[i]);
            }
        }

        return res;
    }
};
```

### N 叉树的后序遍历

**eg 3.2.1 递归**

```C++
class Solution {
public:
    vector<int> res;
    vector<int> postorder(Node* root) {
        postorderTraversal(root);
        return res;
    }

    void postorderTraversal(Node *node) {
        if (node == nullptr) return;

        for (auto &child : node->children) {
            postorderTraversal(child);
        }
        res.emplace_back(node->val);
    }
};
```

**eg 3.2.2 迭代**

```C++
TODO
```

### N 叉树的层序遍历

```C++
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        if (root == nullptr) return res;

        queue<Node*> q;
        q.push(root);
        while (!q.empty()) {
            int size = q.size();
            res.emplace_back(vector<int>());
            while (size--) {
                root = q.front();
                q.pop();
                res.back().emplace_back(root->val);
                for (auto &child : root->children) {
                    q.push(child);
                }
            }
        }

        return res;
    }
};
```

## 参考链接

* [树的遍历](https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86)
* [运用递归解决树的问题](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefb4e/)
