# 广度优先搜索

广度优先搜索算法（Breadth-First Search，BFS）是一种图形搜索算法。该算法系统地展开并检查图中的所有节点，以找寻结果，且在遍历过程中不考虑结果的可能位置。如果所有节点均被访问或找到结果，则算法中止。

所谓广度优先，就是算法需要在发现所有距离源节点 $s$ 为 $k$ 的所有节点之后，才发现距离源节点为 $k + 1$ 的其他节点。这样做的结果是，BFS 算法找到的路径是从起点 $s$ 开始到目标节点 $v$ 的 最短合法路径，即包含最少边数的路径。

广度优先搜索主要适用于以下场景：

* 无权图中找最短路径
* 一些可以抽象为无权图的最短路径的 求解最短、最少、最小的问题
* TODO

目录：

- [广度优先搜索](#广度优先搜索)
  - [算法模板](#算法模板)
    - [基本框架](#基本框架)
  - [BFS 优化](#bfs-优化)
    - [双向 BFS](#双向-bfs)
    - [多源 BFS](#多源-bfs)
  - [常见题型](#常见题型)
    - [树/图的广度优先遍历](#树图的广度优先遍历)
    - [二维平面上的搜索问题](#二维平面上的搜索问题)
    - [抽象成图论问题](#抽象成图论问题)
  - [参考链接](#参考链接)

## 算法模板

### 基本框架

```C++
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node *start, Node *target) {
    if (start == nullptr) return -1; // 注意 1. 特例判断

    queue<Node*> q;                  // 核心数据结构
    unordered_set<Node*> visited;    // 避免重复访问
    
    q.push(start);                   // 起点入队
    visited.insert(start);           // 标记起点
    int step = 0;                    // 记录扩散的步数

    while (q not empty) {
        int size = q.size();         // 注意 2. 提前保存队列中的元素个数

        // 将当前队列中的所有节点（同一层）向四周扩散
        while (size--) {
            Node *cur = q.front(); q.pop(); // 节点出队

            if (cur is target) return step; // 判断是否找到目标

            // 注意 3. 将 cur 的相邻 非空节点 加入队列
            for (Node *x : cur->adj()) {
                if (x not in visited) {     // 防止重复访问
                    q.push(x);
                    visited.insert(x);      // 注意 4. 节点加入队列后，立即标记为「已经访问」
                }
            }
        }

        // 更新步数
        ++step;
    }
}
```

* `visited`：标记集合，用于记录已访问的节点，以避免走回头路。该数组大部分情况下是必需的，但是如果是一般的树形结构，没有子节点到父节点的指针，天然不会有回头路，也就不需要 `visited`。
* `cur->adj()`：泛指 `cur` 的邻接节点。如在二维数组，`cur` 的上下左右四个节点为其邻接节点，在一般的二叉树中，其左右孩子节点为其邻接节点。

**注意：**

* 通常在不进行额外判断的情况下，不能向队列中加入空节点，因为空节点在访问其邻接节点时，会出现 `runtime error: member access within null pointer` 访问空指针的错误，故需要特别注意以下两点：
  * 判断初始起点 `Node *start` 是否为空，如果为空则直接返回结果。
  * 将 `cur` 的相邻节点加入队列时，除判断是否重复以外，还要检查其是否为空，只有在非空的情况下才入队。
* 遍历当前队列中的所有节点时，不能直接用 `q.size()` 作循环判断条件，因为 `q.size()` 在循环中是变量，正确的做法是：遍历队列时提前保存队列中的元素的个数 `int size = q.size();`。
* 广度优先遍历作用于图论问题的时候，将节点加入队列后，需要立即将其标记为「已经访问」（即添加到 `visited` 标记集合中），否则可能导致相同节点重复入队（如：同一层的多个节点含有相同邻接点的情况）。

**运用框架的思考：**

广度优先遍历用于求解「无权图」的最短路径，因此一定要认清「无权图」这个前提条件。如果是带权图，就需要使用相应的专门的算法去解决它们。事实上，这些「专门」的算法的思想也都基于「广度优先遍历」的思想，例举如下：

* 带权有向图、且所有权重都非负的单源最短路径问题：[Dijkstra 算法](https://baike.baidu.com/item/%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/23665989?fr=aladdin)；
* 带权有向图的单源最短路径问题：[Bellman-Ford 算法](https://baike.baidu.com/item/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95)；
* 一个图的所有结点对的最短路径问题：[Floy-Warshall 算法](https://baike.baidu.com/item/floyd-warshall%E7%AE%97%E6%B3%95/9705345)。

## BFS 优化

### 双向 BFS

### 多源 BFS

TODO

## 常见题型

### 树/图的广度优先遍历

### 二维平面上的搜索问题

### 抽象成图论问题

TODO

## 参考链接

* [广度优先搜索](https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)
* [宽度优先搜索](https://bkso.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/
* [LeetBook - 广度优先搜索](https://leetcode-cn.com/leetbook/detail/bfs/)
