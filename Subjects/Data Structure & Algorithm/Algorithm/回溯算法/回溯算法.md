# 回溯算法

回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。

回溯算法主要用于解决：**穷举 / 遍历** 问题。

**穷举法与回溯法的关系：**

* 穷举法：基于试探的思想。将一个解的各个部分全部生成后，才检查是否满足条件，若不满足，则直接放弃该完整解，然后再尝试另一个可能的完整解。它并没有沿着一个可能的完整解的各个部分逐步回退生成解的过程。
* 回溯法：基于试探的思想。一个解的各个部分是逐步生成的，当发现当前生成的某部分不满足约束条件时，就放弃该步所做的工作，退到上一步进行新的尝试，而不是放弃整个解重来，即剪枝优化。

**回溯算法解决问题的一般步骤：**

1. 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。
2. 确定易于搜索的解空间结构，使得能用回溯法方便地搜索整个解空间。
3. 以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。

目录：

- [回溯算法](#回溯算法)
  - [算法模板](#算法模板)
    - [基本框架](#基本框架)
    - [代码模板](#代码模板)
  - [参考链接](#参考链接)

## 算法模板

### 基本框架

```C++
res = []
void backtrack( 路径，选择列表 ) {
    
    // 1. 判断是否遍历结束，即到达决策树叶子节点
    if ( 满足结束条件 ) {
        res.add( 路径 );
        return;
    }

    // 2. 遍历选择列表
    for ( 选择 in 选择列表 ) {

        // 3. 做出选择
        路径.add( 选择 );
        将该选择从选择列表中移除;

        // 4. 递归，进入下一层决策树
        backtrack( 路径, 选择列表);

        // 5. 撤销选择
        路径.remove( 选择 );
        将该选择恢复到选择列表中;
    }
}
```

**运用框架的思考：**

* `当前路径`：当前已经做出的选择。
* `选择列表`：当前可以做的选择。
* `结束条件`：到达决策树底层，无法再做选择的条件。

**注意：** 必须要在递归之前做出选择，在递归之后撤销刚才的选择，才能正确维护每个节点的选择列表和路径。

### 代码模板

**eg 1.** 适用场景：寻找数组或字符集所有可能的全排列。

```C++
/* 给定一个不含重复数字的数组 nums，返回其所有可能的全排列。*/

vector<vector<int>> res; // 记录结果

vector<vector<int>> permute(vector<int>& nums) {
    vector<int> path;                            // 当前路径
    unordered_set<int> selectList;               // 选择列表
    for (int val : nums) selectList.insert(val); // 初始化选择列表
    backtrack(nums, path, selectList);
    return res;
}

void backtrack(vector<int> &nums, vector<int> &path, unordered_set<int> &selectList) {
    
    // 触发结束条件
    if (path.size() == nums.size()) {
        res.emplace_back(path);
        return;
    }

    // 遍历总选择列表
    for (int i = 0; i < nums.size(); ++i) {

        // 排除不合法的选择，即不在当前选择列表中
        if (selectList.count(nums[i]) != 1) continue;

        // 做出选择
        path.push_back(nums[i]);
        selectList.erase(nums[i]);

        // 进入下一层决策树
        backtrack(nums, path, selectList);

        // 撤销选择
        path.pop_back();
        selectList.insert(nums[i]);
    }
}
```

**补充：**

**eg 2.** 适用场景：仅寻找一个可行解。

```C++
// 函数找到一个答案后就返回 true
bool backtrack(vector<string>& board, int row) {
    
    // 触发结束条件
    if (...) {
        res.push_back(board);
        return true;
    }

    // 遍历选择列表
    for (...) {
        
        // 做出选择
        ...

        // 满足条件，直接返回
        if (backtrack(...)) return true;

        // 撤销选择
        ...
    }

    return false;
}
```

**eg 2** 相较于 **eg 1** `backtrack` 方法增加了 `bool` 返回值，只要找到一个可行解，函数便会立刻返回，`for` 循环后的递归穷举都会被阻断。

## 参考链接

* [回溯法](https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95)
* [回溯算法](https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/9258495)
* [滑动窗口技巧 - labuladong的算法小抄](https://labuladong.gitbook.io/algo/mu-lu-ye/hui-su-suan-fa-xiang-jie-xiu-ding-ban)
