# 分治算法

分治，即 “分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即为子问题的解的合并。分治技巧是很多高效算法的基础，如排序算法（归并排序、快速排序）、傅立叶变换（快速傅立叶变换）。

目录：

- [分治算法](#分治算法)
  - [基本思想](#基本思想)
  - [适用场景](#适用场景)
  - [基本步骤](#基本步骤)
  - [典型例题](#典型例题)
  - [参考链接](#参考链接)

## 基本思想

分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模 n 较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。

如果原问题可分割成k个子问题，1< k ≤ n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。

## 适用场景

分治法能够解决的问题一般具有以下几个特征：

* 该问题的规模缩小到一定的程度就可以容易地解决；
* 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；
* 利用该问题分解出的子问题的解可以合并为该问题的解；
  * 如果不具备该特征可以考虑用贪心算法或动态规划。
* 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。（非必须）
  * 该特征涉及到分治法的效率，如果分解出来的各个子问题需要重复地解决公共的子问题，此时虽然也能用分治法，但是一般使用动态规划法更好。

## 基本步骤

在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：

1. **分解**（Divide）步骤将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
2. **解决**（Conquer）步骤递归地求解子问题，若子问题的规模足够小，则停止递归，直接求解；
3. **合并**（Combine）步骤将各个子问题的解合并为原问题的解。

其一般的算法设计模式如下：

```C++
Divide-and-Conquer(P)

// 基本情况（base case）：子问题足够小，可直接求解
1. if |P| ≤ n0

2. then return(ADHOC(P))

// 递归情况（recursive case）：子问题足够大，需要递归求解
3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk

4. for i←1 to k

5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi

6. T ← MERGE(y1,y2,...,yk) △ 合并子问题

7. return(T)
```

其中 |P| 表示问题 P 的规模；n0 为一阈值，表示当问题 P 的规模不超过 n0 时，问题已容易直接解出，不必再继续分解。ADHOC(P) 是该分治法中的基本子算法，用于直接解小规模的问题 P。因此，当 P 的规模不超过 n0 时直接用算法 ADHOC(P) 求解。算法 MERGE(y1,y2,...,yk) 是该分治法中的合并子算法，用于将 P 的子问题 P1 ,P2 ,...,Pk 的相应的解 y1,y2,...,yk 合并为 P 的解。

## 典型例题

TODO

## 参考链接

* [分治法 - wiki](https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95)
* [五大常用算法之一：分治算法](https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html)
