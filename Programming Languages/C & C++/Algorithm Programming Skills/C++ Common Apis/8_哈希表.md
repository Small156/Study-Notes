# C++ 哈希表

目录：

- [C++ 哈希表](#c-哈希表)
  - [map](#map)
    - [声明及初始化](#声明及初始化)
    - [遍历哈希表](#遍历哈希表)
    - [基本操作](#基本操作)
  - [unordered_map](#unordered_map)
    - [声明及初始化](#声明及初始化-1)
    - [遍历无序哈希表](#遍历无序哈希表)
    - [基本操作](#基本操作-1)
  - [multimap](#multimap)
  - [参考链接](#参考链接)

## map

### 声明及初始化

使用哈希表 `map` 时，需引入头文件 `<map>`。

```C++
#include <map>

// 初始化一个空的 map
map<int, int> mappings;

// 通过初始化列表中的键值对，对其进行初始化
map<char, char> pairs = {
    {')', '('},
    {']', '['},
    {'}', '{'}
};

// 范围构造函数 - 插入 [first,last) 范围内的元素
vector<pair<int, int>> arr = {{1, 2}, {3, 4}};
map<int, int> mappings(arr.begin(), arr.end());
```

### 遍历哈希表

**eg 1. 基于范围的 for 循环遍历**

```C++
// pair<const type, type> item
for (auto item : mappings) {
    cout << item.first << " " << item.second << endl;
}
```

**eg 2. 基于迭代器遍历**

```C++
// 可用 auto 关键字简化 auto iter = mappings.begin()
for (map<int, int>::iterator iter = mappings.begin(); iter != mappings.end(); ++iter) {
    cout << iter->first << " " << iter->second << endl;
}
```

### 基本操作

**基础操作：**

```C++
// 返回哈希表中的键值对个数
size_type size();

// 返回哈希表是否为空，如果不为空返回 1，否则返回 0
bool empty();

// 如果 key 存在返回 1，否则返回 0
size_type count(const key_type& key);

// 通过 key 或 迭代器指针删除哈希表中的键值对，如果删除成功则返回 1，否则返回 0
size_type erase (const key_type& key);
iterator  erase (const_iterator position);
iterator  erase (const_iterator first, const_iterator last);

// 将哈希表 size 设置为 0，但 capacity 不变（注意：不能用于清空哈希表）
void clear();
```

**元素访问：**

```C++
/* 1. 返回指向 map 首个 / past-the-end 元素的 iterator 指针
注意：past-the-end 不指向任何元素，故不能被解引用 */
      iterator begin() noexcept;
const_iterator begin() const noexcept;
      iterator end() noexcept;
const_iterator end() const noexcept;

// 示例
cout << (--mappings.end())->first << " "  // 输出 map 最后一个元素
     << (--mappings.end())->second;
auto it = mappings.end();
--it; --it;
cout << it->first << " " << it->second;   // 输出 map 倒数第 2 个元素

/* 2. 反向迭代器，rbegin() 指向最后一个元素，rend() 指向第一个元素之前的理论元素，不可解引用 */
      reverse_iterator rbegin() noexcept;
const_reverse_iterator rbegin() const noexcept;
      reverse_iterator rend() noexcept;
const_reverse_iterator rend() const noexcept;

// 示例
cout << mappings.rbegin()->first << " "     // 输出 map 最后一个元素
     << mappings.rbegin()->second;  
cout << (++mappings.rbegin())->first << " " // 输出 map 倒数第 2 个元素
<< (++mappings.rbegin())->second;
```

> **注意：**
> **①** `map` 没有类似于 `vector` 的 `front()`、`back()` 方法，只能通过迭代器访问首尾元素。
>
> **②** `map` 为关联式容器，不能像 `vector` 之类的序列式容器那样实现随机访问（Random Access），
故其迭代器不能使用 `+=、-= 、- 、+` 运算符，只能使用 `++、--` 运算符。
>
> **③** `begin()`，`end()` 方法返回的迭代器指向类型为 `pair<const type, type>` 由于 `map` 内部以 `key` 为关键值排序，故可以通过 `begin()` 关键字修改头元素，并 `mappings.erase(mappings.begin())` 实现删除 `map` 头元素的功能，以实现等价于 优先队列 + 哈希计数 的效果。

## unordered_map

### 声明及初始化

使用无序哈希表 `unordered_map` 时，需引入头文件 `<unordered_map>`。

```C++
#include <unordered_map>

// 初始化一个空的 unordered_map
unordered_map<int, int> mapping;

// 通过初始化列表中的键值对，对其进行初始化
unordered_map<char, char> pairs = {
    {')', '('},
    {']', '['},
    {'}', '{'}
};

// 范围构造函数 - 插入 [first,last) 范围内的元素
vector<pair<int, int>> arr = {{1, 2}, {3, 4}};
unordered_map<int, int> mappings(arr.begin(), arr.end());
```

### 遍历无序哈希表

**eg 1. 基于范围的 for 循环遍历**

```C++
// pair<const type, type> item
for (auto item : mapping) {
    cout << item.first << " " << item.second << endl;
}
```

**eg 2. 基于迭代器遍历**

```C++
// 可用 auto 关键字简化 auto iter = mapping.begin()
for (unordered_map<int, string>::iterator iter = mapping.begin(); iter != mapping.end(); ++iter) {
    cout << iter->first << " " << iter->second << endl;
}
```

### 基本操作

```C++
// 返回哈希表中的键值对个数
size_type size();

// 返回哈希表是否为空，如果不为空返回 1，否则返回 0
bool empty();

// 如果 key 存在返回 1，否则返回 0
size_type count(const key_type& key);

// 通过 key 删除哈希表中的键值对，如果删除成功则返回 1，否则返回 0
size_type erase(const key_type& key);

// 将哈希表 size 设置为 0，但 capacity 不变（注意：不能用于清空哈希表）
void clear();
```

> **注意：** 用 `[]` 访问其中的键 `key` 时，如果 `key` 不存在，则会自动创建 `key`，对应的值为该值类型的默认值。

## multimap

TODO

## 参考链接

* [C++ Reference](http://www.cplusplus.com/reference/)
