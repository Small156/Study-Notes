# Effective C++ 5. 实现

本文主要为 Effective C++ 条款 26 - 31 的学习与总结。

目录：

- [Effective C++ 5. 实现](#effective-c-5-实现)
  - [条款 26：尽可能延后变量定义式的出现时间](#条款-26尽可能延后变量定义式的出现时间)
  - [条款 27：尽量少做转型动作](#条款-27尽量少做转型动作)
  - [条款 28：避免返回 handles 指向对象内部成分](#条款-28避免返回-handles-指向对象内部成分)
  - [条款 29：为 “异常安全” 而努力是值得的](#条款-29为-异常安全-而努力是值得的)
  - [条款 30：透彻了解 inlining 的里里外外](#条款-30透彻了解-inlining-的里里外外)
  - [条款 31：将文件间的编译依存关系降至最低](#条款-31将文件间的编译依存关系降至最低)
  - [参考资料](#参考资料)

## 条款 26：尽可能延后变量定义式的出现时间

> **问题：** 函数过早定义变量，但由于函数中途出现异常被抛出或者其他情况，导致该变量未被真正使用。
> **后果：** 白白耗费了变量的构造与析构成本。

**记住：** 延后变量的定义，直到非得使用该变量的前一刻为止，并且最好是延后至能够给他初值实参为止。

**优点：**

* 避免构造（和析构）不必要对象。
* 避免无意义的 default 构造行为，同时以具有明显意义的初值将变量初始化，还可以附带说明变量的作用。
  * 直接在构造时指定初值（仅调用一次 copy 构造函数）比 通过 default 构造函数构造一个对象，然后对它赋值（先调用 default 构造函数，再调用 copy assignment 运算符）更高效（参见 条款 04）。

如果是循环情况，变量仅在循环内使用，那么变量的定义方式将视情况而定。

```C++
// 方法 A：定义与循环外
// 成本：1 个构造函数 + 1 个析构函数 + n 个赋值操作
/* 潜在负面影响：造成变量 w 的作用域（覆盖整个循环）比 方法 B 更大，
有时会对程序可理解性和易维护性造成冲突。*/
Widget w;
for (int i = 0; i < n; ) {
    w = 取决于 i 的某个值
    ...
}

// 方法 B：定义与循环内
// 成本：n 个构造函数 + n 个析构函数
for (int i = 0; i < n; ) {
    Widget w(取决于 i 的某个值);
}
```

一般而言，除非以下两种情况：

* 明确知道 赋值成本 比 “构造 + 析构” 成本低
* 处理代码中效率高度敏感的部分

否则应该使用方法 B。

## 条款 27：尽量少做转型动作

## 条款 28：避免返回 handles 指向对象内部成分

## 条款 29：为 “异常安全” 而努力是值得的

## 条款 30：透彻了解 inlining 的里里外外

## 条款 31：将文件间的编译依存关系降至最低

## 参考资料

* 《Effective C++：改善程序与设计的55个具体做法》（第3版 中文版）
