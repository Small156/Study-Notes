# C learning

C 相关知识点总结。

目录：

- [C learning](#c-learning)
  - [编译过程](#编译过程)
  - [预处理器](#预处理器)
    - [#define](#define)
    - [#undef](#undef)
    - [#include](#include)
    - [条件编译](#条件编译)
  - [void 类型](#void-类型)
  - [结构体 TODO](#结构体-todo)
  - [项目结构 TODO](#项目结构-todo)
  - [make cmake  makefile 工具 TODO](#make-cmake--makefile-工具-todo)
  - [GDB TODO](#gdb-todo)
  - [数据类型 TODO](#数据类型-todo)
  - [存储类 TODO](#存储类-todo)
  - [作用域 TODO](#作用域-todo)
  - [参考链接](#参考链接)

## 编译过程

通过 `gcc xxx.c -o xxx` 命令编译源代码 `xxx.c` 并生成可执行文件 `xxx` 的过程，可分为以下 4 个步骤：

预处理/预编译 -> 编译 -> 汇编 -> 链接

可通过 gcc 命令参数实现逐步执行，示例如下：

```bash
gcc -E hello.c -o hello.i # 实现预处理，通过预处理器处理源代码中的预处理指令
gcc -S hello.i -o hello.s # 实现编译，生成汇编代码文件
gcc -c hello.s -o hello.o # 实现汇编，生成机器指令文件
gcc hello.o -o hello      # 实现链接，生成可执行文件
```

具体实现工作：

* 预处理

  * 处理所有的注释，以空格代替
  * 将所有的 #define 删除，并且展开所有的宏定义
  * 处理条件编译指令 #if，#ifdef、#elif，#else、#endif
  * 处理 #include，展开文件包含
  * 保留编译器需要使用 #pragma 指令

* 编译

  * 对预处理文件进行语法分析、词法分析、语义分析
  * 语法分析：分析表达式是否遵循语法规则
  * 词法分析：分析关键字，标识符，立即数是否合法
  * 语义分析：在语法分析基础上进一步分析表达式是否合法
  * 分析结束后进行代码优化生成相应的汇编代码文件
  
* 汇编

  * 汇编器将汇编代码转变为机器可以执行的指令，也就是机器指令

* 链接

  * 链接是指将目标文件最终生成可执行文件
  * 根据链接方式的不同，链接过程可以分为：
    * 静态链接：目标文件直接进入可执行文件
    * 动态链接：在程序启动后才动态加载目标文件

## 预处理器

C 预处理器不是编译器的组成部分，它在整个编译过程中的预处理/预编译阶段发挥作用，主要功能是根据源代码预处理指令实现文本替换和条件编译等。

所有预处理指令都是以 `#` 开头且必须是第一个非空字符。

常见预处理指令：

指令 | 描述
--- | ---
\#define | 定义宏
\#include | 包含一个源代码文件
\#undef | 取消已定义的宏
\#ifdef | 如果宏已经定义，则返回真
\#ifndef | 如果宏没有定义，则返回真
\#if | 如果给定条件为真，则编译下面代码
\#else | #if 的替代方案
\#elif | 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
\#endif | 结束一个 #if……#else 条件编译块
\#error | 当遇到标准错误时，输出错误消息
\#pragma | 使用标准化方法，向编译器发布特殊的命令到编译器中

### #define

预处理指令从 `#` 开始，到其后第一个换行符为止。即，指令的长度限于一行代码。若想把指令扩展到几个物理行，可使用反斜线后紧跟换行符的方法实现。

\#define 命令由三部分组成：

1. #define 命令本身
2. 所选择的缩略语 —— 宏（分为对象宏和函数宏）。宏的名字中不允许有空格，而且必须遵循 C 变量命名规则：只能使用字母、数字和下划线 _，第一个字符不能为数字。习惯上宏名用大写字母表示，以便于与变量区别。
3. （#define行的其余部分）称为替换列表或主体。

**函数宏：**

通过使用参数，可以创建外形和作用都与函数相似的类函数宏。宏的参数也用圆括号括起来。

```c
#define SQUARE(X) X*X
```

**注意：预处理器不进行计算，而只进行字符串替换，因此需要使用足够多的圆括号来保证正确的优先级。**

示例：

```c
// eg 1
#define SQUARE(X) X*X

int num = 4;
printf("res = %d", SQUARE(num + 2));
// res = 4 + 2*4 + 2 = 14

// eg 2
#define SQUARE(X) ((X)*(X))

int num = 4;
printf("res = %d", SQUARE(num + 2));
// res = (4 + 2)*(4 + 2) = 36
```

**typedef 和 #define 的区别：**

宏定义只是简单的字符串代换，是在预处理完成的，而typedef是在编译时处理的，它不是作简单的代换，而是对类型说明符重新命名。被命名的标识符具有类型定义说明的功能。

示例：

```c
#define P1 int *
typedef (int *) P2
```

从形式上看这两者相似，但在实际使用中却不相同。

下面用 `P1`、`P2` 说明变量时就可以看出它们的区别：

`P1 a, b;` 在宏代换后变成：`int *a, b;` 表示 `a` 是指向整型的指针变量，而 `b` 是整型变量。
`P2 a, b;`  表示 `a`,`b` 都是指向整型的指针变量。

由上述示例可见，宏定义虽然也可表示数据类型，但由于是作字符代换，使用时需要额外注意。

总结：

* 与 `#define` 不同，`typedef` 给出的符号名称仅限于对类型，而不是对值。
* `typedef` 的解释由编译器，而不是预处理器执行。
* `typedef` 比 `#define` 更灵活。

### #undef

取消定义一个给定的 #define。

即使没有定义，也可以合法 undef。如果想使用一个特定名字，但又不能确定前面是否已经使用了该名字，为安全起见，就可以先取消该名字的定义。

### #include

预处理器发现 `#include` 指令后，就会寻找后跟的文件名并把这个文件的内容包含但当前文件中。被包含文件中的文件将替换源代码文件中的#include指令。

\#include 指令有两种使用形式：

* #include <filename.h> 尖括号，告知预处理器在一个或多个标准系统目录中寻找文件。
* #include "filename.h" 双引号，告知预处理器在当前目录中寻找文件，若没有找到再到系统目录中寻找。

### 条件编译

* \#ifdef 如果宏已经定义，则返回真
* \#ifndef 如果宏没有定义，则返回真
* \#if 如果给定条件为真，则编译下面代码
* \#else #if 的替代方案
* \#elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
* \#endif 结束一个 #if……#else 条件编译块

示例：

```c
#ifdef 标识符 
程序段1 
#else 
程序段2 
#endif
```

表示若标识符已经被定义过（一般用 `#define` 命令定义），则对程序段 1 进行编译，否则编译程序段 2。

**应用示例：**

**eg1. 头文件警卫**

头文件警卫（header guard），用于防止当前头文件被同一个 `.cpp` 文件直接或间接多次包含，因为头文件中一般包含类的定义以及常量的定义，如果多次被同一个 `.cpp` 文件包含的话会导致链接错误（重复定义）。

假设某头文件名为 `xxx.h`，则该头文件应具有以下头文件警卫内容：

```c
#ifndef XXX_H
#define XXX_H
// 类定义
// 常量声明/定义
// 函数声明
#endif
```

**eg2. 提升程序通用性**

若一个 C 语言程序需要在不同的计算机系统上运行，而不同的计算机又有一定差异，例如，某一数据类型在 Win 下为 `long` 类型，而在其他平台需要使用 `float` 表示，此时就可以采用条件编译，在不改变源程序的情况下，提升程序的通用性。

```c
#ifdef WINDOWS 
#define MYTYPE long 
#else 
#define MYTYPE float 
#endif 
```

若在 `Win` 下编译，则只需在程序开头添加 `#define WINDOWS` 即可。

**eg3. 调试程序**

在调试程序过程中，经常需要通过输出信息到控制台或日志，来获取必要信息。同时在调试完成后又不再需要输出这些信息。

可以通过插入以下条件编译段实现该功能：

```c
#ifdef DEBUG 
print ("device_open(%p)\n", file); 
#endif
```

若需开启调试，则只需在程序开头添加 `#define DEBUG` 即可。

**eg4. 选择性编译**

若程序某部分功能，不对所有人开放，则可通过条件编译，实现仅对指定用户提供该功能。

```c
#define HNLD：
#ifdef HNLD
include"n166_hn.c"
#endif
```

若不提供该功能，则将头部定义 `HNLD` 加下划线变为 `_HNLD` 即可。

若涉及硬件设别，在本地缺乏相应硬件测试环境时，可通过条件编译，绕过具体实现，用预设参数进行模拟。

```c
#ifndef TEST
// 程序调试运行时绕过此语句
i=dial();
#else
i=0;
#endif
```

调试通过后，再屏蔽 `TEST` 的定义并重新编译，即可调用真实硬件设备。

## void 类型

void 类型表示没有可用的值。它通常用于以下三种情况：

* 函数返回为空
C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);
* 函数参数为空
C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);
* 指针指向 void
  * 类型为 void \* 的指针代表对象的地址，而不是类型。例如，内存分配函数 void \*malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。
  * 任何类型的指针都可以直接赋值给 void \* 类型指针，无需进行强制类型转化。

  ```c
  void *p1;
  int *p2;
  p1 = p2;
  ```

  * void \* 类型指针必须通过强制类型转化才能赋值给其他类型指针。

  ```c
  char *Ptr = NULL;
  Ptr = (char *)malloc(100 * sizeof(char));
  ```

  * 总结：“无类型”可以包容“有类型”，而“有类型”则不能包容“无类型”。

## 结构体 TODO

## 项目结构 TODO

## make cmake  makefile 工具 TODO

## GDB TODO

## 数据类型 TODO

## 存储类 TODO

## 作用域 TODO

## 参考链接

* [C语言再学习 -- C 预处理器](https://blog.csdn.net/qq_29350001/article/details/53158517)
* [C 预处理器](https://www.runoob.com/cprogramming/c-preprocessors.html)
* [C语言编译和链接过程简介](https://blog.csdn.net/liuchunjie11/article/details/80252811)
* [c++ 头文件中加入 #ifnodef #define #engif 有什么用](https://zhidao.baidu.com/question/808302537705193412.html)
